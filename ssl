#!/bin/bash

# Exit immediately on error
set -e

# Version
version="v0.1.0"

# Detect whether output is piped or not.
[[ -t 1 ]] && piped=0 || piped=1

# Defaults
force=0
quiet=0
verbose=0
args=()
path=$(dirname "$(realpath $0)")

##
# Helper
##

out() {
  ((quiet)) && return

  local message="$*"
  if ((piped)); then
    message=$(echo $message | sed '
      s/\\[0-9]\{3\}\[[0-9]\(;[0-9]\{2\}\)\?m//g;
      s/✖/Error:/g;
      s/✔/Success:/g;
    ')
  fi
  printf '%b\n' "$message";
}

die() { out "$*"; exit 1; } >&2
err() { out " \033[1;31m✖\033[0m  $*"; } >&2
success() { out " \033[1;32m✔\033[0m  $*"; }

# Verbose logging
verboselog() { (($verbose)) && out "$*"; }

# Notify on function success
notify() { [[ $? == 0 ]] && success "$*" || err "$*"; }

# Escape a string
escape() { echo "$*" | sed 's/\//\\\//g'; }

# Unless force is used, confirm with user
confirm() {
  (($force)) && return 0;

  read -p "$1 [y/N] " -n 1;
  [[ $REPLY =~ ^[Yy]$ ]];
}

# Print usage
usage() {
  echo -n "Usage: $ $(basename $0) [OPTION] [COMMAND]...

Description of this script.

 Options:
  -q, --quiet       Quiet (no output)
  -v, --verbose     Output more
  -h, --help        Display this help and exit
      --version     Output version information and exit

 Available commands:
  csr               Quiet (no output)
  host              Output more

  Run \"$(basename $0) [command] -h\" for further information
"
}

# Set a trap for cleaning up in case of errors or when script exits.
rollback() {
  die
}

# Iterate over options breaking -ab into -a -b when needed and --foo=bar into --foo bar
optstring=h
unset options
while (($#)); do
  case $1 in
    # If option is of type -ab
    -[!-]?*)
      # Loop over each character starting with the second
      for ((i=1; i < ${#1}; i++)); do
        c=${1:i:1}

        # Add current char to options
        options+=("-$c")

        # If option takes a required argument, and it's not the last char make
        # the rest of the string its argument
        if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # If option is of type --foo=bar
    --?*=*) options+=("${1%%=*}" "${1#*=}") ;;
    # add --endopts for --
    --) options+=(--endopts) ;;
    # Otherwise, nothing special
    *) options+=("$1") ;;
  esac
  shift
done
set -- "${options[@]}"
unset options

# Set our rollback function for unexpected exits.
trap rollback INT TERM EXIT

# A non-destructive exit for when the script exits naturally.
safe_exit() {
  trap - INT TERM EXIT
  exit
}

# Print help if no arguments were passed.
[[ $# -eq 0 ]] && set -- "--help"

# Read the options and set stuff
while [[ $1 = -?* ]]; do
  case $1 in
    -h|--help) usage >&2; safe_exit ;;
    --version) out "$(basename $0) $version"; safe_exit ;;
    -v|--verbose) verbose=1 ;;
    -q|--quiet) quiet=1 ;;
    --endopts) shift; break ;;
    *) die "invalid option: $1" ;;
  esac
  shift
done

# Store the remaining part as arguments.
args=$(echo "$*" | sed 's/^[^ ][^ ]* //')

# Check if subcommand exists
if [[ -f "${path}/$(basename $0)-$1" ]]; then
  . "${path}/$(basename $0)-$1" "${args}"
else
  usage >&2
fi

# This has to be run last not to rollback changes we've made.
safe_exit
